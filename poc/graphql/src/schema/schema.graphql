# ============================================================================
# TravelMatch GraphQL Schema
# ============================================================================

scalar DateTime
scalar Upload
scalar JSON

# ============================================================================
# Enums
# ============================================================================

enum MomentType {
  COFFEE
  LUNCH
  DINNER
  DRINKS
  ACTIVITY
  ADVENTURE
  CULTURAL
  NIGHTLIFE
  OUTDOORS
  OTHER
}

enum MomentStatus {
  ACTIVE
  PENDING
  COMPLETED
  CANCELLED
  EXPIRED
}

enum MatchStatus {
  PENDING
  ACCEPTED
  REJECTED
  EXPIRED
  BLOCKED
}

enum UserRole {
  USER
  MODERATOR
  ADMIN
}

# ============================================================================
# Core Types
# ============================================================================

type User {
  id: ID!
  email: String!
  name: String!
  avatarUrl: String
  bio: String
  trustScore: Int!
  isVerified: Boolean!
  role: UserRole!
  createdAt: DateTime!
  updatedAt: DateTime!
  lastActiveAt: DateTime
  
  # Relations (efficiently loaded with DataLoader)
  profile: UserProfile
  moments(
    first: Int
    after: String
    filter: MomentFilter
  ): MomentConnection!
  matches(status: MatchStatus): [Match!]!
  notifications(unreadOnly: Boolean): [Notification!]!
  
  # Stats
  stats: UserStats!
}

type UserProfile {
  userId: ID!
  phoneNumber: String
  dateOfBirth: DateTime
  location: Location
  interests: [String!]!
  languages: [String!]!
  preferredMomentTypes: [MomentType!]!
  maxTravelDistance: Int
  privacySettings: PrivacySettings!
}

type UserStats {
  totalMoments: Int!
  completedMoments: Int!
  totalMatches: Int!
  successfulMatches: Int!
  averageRating: Float
}

type PrivacySettings {
  showLocation: Boolean!
  showAge: Boolean!
  showLastActive: Boolean!
  allowMessages: Boolean!
}

type Moment {
  id: ID!
  title: String!
  description: String
  type: MomentType!
  price: Float
  currency: String!
  maxParticipants: Int!
  currentParticipants: Int!
  location: Location!
  imageUrl: String
  videoUrl: String
  status: MomentStatus!
  startsAt: DateTime
  expiresAt: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
  
  # Relations
  creator: User!
  participants: [User!]!
  comments(first: Int, after: String): CommentConnection!
  likes: [Like!]!
  
  # Stats
  likeCount: Int!
  commentCount: Int!
  viewCount: Int!
  
  # Computed
  isJoined: Boolean!
  isLiked: Boolean!
  distance(from: LocationInput!): Float
}

type Match {
  id: ID!
  status: MatchStatus!
  matchedAt: DateTime!
  acceptedAt: DateTime
  rejectedAt: DateTime
  expiresAt: DateTime
  
  # Relations
  user1: User!
  user2: User!
  moment: Moment
  messages(first: Int, after: String): MessageConnection!
  
  # Stats
  messageCount: Int!
  lastMessageAt: DateTime
  
  # Computed
  isActive: Boolean!
  unreadCount: Int!
}

type Message {
  id: ID!
  content: String!
  matchId: ID!
  senderId: ID!
  createdAt: DateTime!
  readAt: DateTime
  
  # Relations
  sender: User!
  match: Match!
  
  # Computed
  isRead: Boolean!
}

type Comment {
  id: ID!
  content: String!
  momentId: ID!
  userId: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  
  # Relations
  author: User!
  moment: Moment!
  replies(first: Int): [Comment!]!
  
  # Stats
  replyCount: Int!
}

type Like {
  id: ID!
  userId: ID!
  momentId: ID!
  createdAt: DateTime!
  
  # Relations
  user: User!
  moment: Moment!
}

type Notification {
  id: ID!
  userId: ID!
  type: String!
  title: String!
  message: String!
  data: JSON
  readAt: DateTime
  createdAt: DateTime!
  
  # Relations
  user: User!
  
  # Computed
  isRead: Boolean!
}

type Location {
  latitude: Float!
  longitude: Float!
  address: String
  city: String
  country: String
  postalCode: String
}

# ============================================================================
# Pagination
# ============================================================================

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type MomentEdge {
  cursor: String!
  node: Moment!
}

type MomentConnection {
  edges: [MomentEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type MessageEdge {
  cursor: String!
  node: Message!
}

type MessageConnection {
  edges: [MessageEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type CommentEdge {
  cursor: String!
  node: Comment!
}

type CommentConnection {
  edges: [CommentEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type UserConnection {
  edges: [UserEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type UserEdge {
  cursor: String!
  node: User!
}

# ============================================================================
# Inputs
# ============================================================================

input LocationInput {
  latitude: Float!
  longitude: Float!
  address: String
  city: String
  country: String
}

input MomentFilter {
  types: [MomentType!]
  minPrice: Float
  maxPrice: Float
  location: LocationInput
  radius: Int
  status: MomentStatus
  creatorId: ID
}

input UserFilter {
  isVerified: Boolean
  minTrustScore: Int
  location: LocationInput
  radius: Int
}

input CreateMomentInput {
  title: String!
  description: String
  type: MomentType!
  price: Float
  currency: String!
  maxParticipants: Int!
  location: LocationInput!
  imageUrl: String
  startsAt: DateTime
  expiresAt: DateTime!
}

input UpdateMomentInput {
  title: String
  description: String
  price: Float
  maxParticipants: Int
  location: LocationInput
  imageUrl: String
  startsAt: DateTime
  expiresAt: DateTime
  status: MomentStatus
}

input UpdateProfileInput {
  name: String
  bio: String
  phoneNumber: String
  dateOfBirth: DateTime
  location: LocationInput
  interests: [String!]
  languages: [String!]
  preferredMomentTypes: [MomentType!]
  maxTravelDistance: Int
}

input PrivacySettingsInput {
  showLocation: Boolean
  showAge: Boolean
  showLastActive: Boolean
  allowMessages: Boolean
}

# ============================================================================
# Queries
# ============================================================================

type Query {
  # User queries
  me: User
  user(id: ID!): User
  users(
    filter: UserFilter
    first: Int
    after: String
  ): UserConnection!
  
  # Moment queries
  moment(id: ID!): Moment
  moments(
    filter: MomentFilter
    first: Int = 20
    after: String
  ): MomentConnection!
  discoverMoments(
    location: LocationInput!
    radius: Int! = 5000
    types: [MomentType!]
    first: Int = 20
  ): [Moment!]!
  myMoments(status: MomentStatus): [Moment!]!
  
  # Match queries
  match(id: ID!): Match
  myMatches(status: MatchStatus): [Match!]!
  
  # Message queries
  messages(matchId: ID!, first: Int, after: String): MessageConnection!
  
  # Notification queries
  myNotifications(unreadOnly: Boolean): [Notification!]!
  unreadNotificationCount: Int!
  
  # Search
  search(
    query: String!
    type: String!
    location: LocationInput
    radius: Int
  ): SearchResults!
}

type SearchResults {
  users: [User!]!
  moments: [Moment!]!
  total: Int!
}

# ============================================================================
# Mutations
# ============================================================================

type Mutation {
  # User mutations
  updateProfile(input: UpdateProfileInput!): User!
  updatePrivacySettings(input: PrivacySettingsInput!): User!
  uploadAvatar(file: Upload!): User!
  deleteAccount: Boolean!
  
  # Moment mutations
  createMoment(input: CreateMomentInput!): Moment!
  updateMoment(id: ID!, input: UpdateMomentInput!): Moment!
  deleteMoment(id: ID!): Boolean!
  joinMoment(momentId: ID!): Moment!
  leaveMoment(momentId: ID!): Moment!
  likeMoment(momentId: ID!): Moment!
  unlikeMoment(momentId: ID!): Moment!
  
  # Comment mutations
  addComment(momentId: ID!, content: String!): Comment!
  updateComment(id: ID!, content: String!): Comment!
  deleteComment(id: ID!): Boolean!
  
  # Match mutations
  createMatch(userId: ID!, momentId: ID): Match!
  acceptMatch(matchId: ID!): Match!
  rejectMatch(matchId: ID!): Match!
  unmatch(matchId: ID!): Boolean!
  
  # Message mutations
  sendMessage(matchId: ID!, content: String!): Message!
  markMessageAsRead(messageId: ID!): Message!
  markAllMessagesAsRead(matchId: ID!): Boolean!
  
  # Notification mutations
  markNotificationAsRead(notificationId: ID!): Notification!
  markAllNotificationsAsRead: Boolean!
}

# ============================================================================
# Subscriptions (Real-time)
# ============================================================================

type Subscription {
  # Moment subscriptions
  momentCreated(
    location: LocationInput!
    radius: Int!
  ): Moment!
  momentUpdated(momentId: ID!): Moment!
  momentDeleted(momentId: ID!): ID!
  
  # Match subscriptions
  matchReceived: Match!
  matchUpdated(matchId: ID!): Match!
  
  # Message subscriptions
  messageReceived(matchId: ID!): Message!
  
  # Notification subscriptions
  notificationReceived: Notification!
  
  # Presence
  userPresenceChanged(userId: ID!): UserPresence!
}

type UserPresence {
  userId: ID!
  isOnline: Boolean!
  lastActiveAt: DateTime
}
